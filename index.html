<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <title>זריחה ושקיעה</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/duration.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/customParseFormat.js"></script>
 
  <style>
    body {
      font-family: "David", sans-serif;
      font-weight: bold;
      background-color: #f8f3e8;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
      direction: rtl;
    }

    #wrapper {
      width: 100%;
      height: 100%;
      position: relative;
    }

    #current-time-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 2;
      max-width: 65vw;
    }

    #current-time {
      font-size: 380px;
      direction: ltr;
      display: inline-block;
    }

    #current-time .regular-seconds {
      font-size: 50%;
      color: red;
    }

    .label {
      font-family: 'Guttman-Aram', serif;
      color: #5e1300;
      font-size: 68px;
      margin-top: 10px;
    }

    .title {
      font-family: 'Guttman-Aram', serif, Tahoma, sans-serif;
      color: black;
      font-size: 40px;
      margin-top: 10px;
    }
   
    #current-date {
      font-family: Tahoma, sans-serif;
      font-size: 40px;
      color: black;
    }
   
    .zman-time {
        font-size: 68px;
        color: #004d40;
    }
   
    .zman-time-tomorrow {
        font-size: 40px;
        color: #004d40;
    }

    .top-right, .top-left, .bottom-right, .bottom-left {
      position: absolute;
      text-align: right;
      z-index: 3;
    }

    .top-right { top: 20px; right: 20px; }
    .top-left { top: 20px; left: 20px; text-align: left; }
    .bottom-right { bottom: 20px; right: 20px; text-align: right; }
    .bottom-left { bottom: 20px; left: 20px; text-align: left; }

    .countdown-netz {
      font-size: 200px;
      color: blue;
    }

    .countdown-sunset {
      font-size: 200px;
      color: orange;
    }

    .clock {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 130%;
      opacity: 0.3;
    }
   
    #netz-countdown-container, #sunset-countdown-container {
        display: block;
    }
  </style>
</head>
<body>
  <div id="wrapper">
    <canvas id="clock" class="clock"></canvas>

    <div id="current-time-container">
      <span id="current-time">--:--:--</span>
    </div>

    <div id="top-right">
      <span class="label" id="dateHeb"></span><br>
      <span class="title" id="current-date"></span><br>
      <span class="title">פרשת השבוע </span>
      <span class="label" id="parashaName"></span>
      <div id="omer-count" class="label"></div>
    </div>

    <div class="top-left">
      <span class="title">הדף היומי </span>
      <span class="label" id="dailyDaf"></span>
    </div>

    <div class="bottom-right">
        <div>
          <span class="title">עלות השחר</span>
          <span class="zman-time" id="alot-hashahar-time">--:--</span>
        </div>
        <div>
          <span class="title">נץ החמה</span>
          <span class="zman-time" id="sunrise-time">--:--</span>
        </div>
        <div id="netz-countdown-container">
            <div><span class="title" id="netz-countdown-title">ספירה לנץ</span></div>
            <div id="countdown-netz" class="countdown-netz">--:--:--</div>
        </div>
    </div>

    <div class="bottom-left">
      <div><span class="title">שקיעה היום </span>
        <span class="zman-time" id="sunset-time">--:--</span></div>
      <div id="sunset-countdown-container">
        <div><span class="title" id="sunset-countdown-title">ספירה לשקיעה</span></div>
        <div id="countdown-sunset" class="countdown-sunset">--:--:--</div>
      </div>
    </div>
  </div>

<script>
(function(){
var canvas = document.getElementById('clock');

var Clock = function(canvas, radius) {
this.canvas = canvas;
this.ctx = this.canvas.getContext('2d');

this.secondHandOptions = {
color: '#cd151c',
thicknessRatio: 0.0075,
forwardRadiusRatio: 0.75,
backwardRadiusRatio: 0.25,
tipRadiusRatio: 0.075
}

this.minuteHandOptions = {
color: '#000',
thicknessRatio: 0.06,
forwardRadiusRatio: 0.875,
backwardRadiusRatio: 0.25
}

this.hourHandOptions = {
color: '#000',
thicknessRatio: 0.08,
forwardRadiusRatio: 0.6,
backwardRadiusRatio: 0.25
}

this.markerOptions = {
color: '#000',
edgeDistanceRatio: 0.05,
thicknessRatio: 0.01,
lengthRatio: 0.1,
keyMarkers: 5,
keyMarkerThicknessRatio: 0.075,
keyMarkerLengthRatio: 0.2
}

this.radius = radius;

this.update();
};

Clock.prototype.update = function() {
    this.center = {
      x: this.canvas.width * 0.5,
      y: this.canvas.height * 0.5
    }

this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
this.drawFace();
this.drawMinuteMarkers();
this.drawHourHand();
this.drawMinuteHand();
this.drawSecondHand();
this.drawPin();
};

Clock.prototype.drawFace = function() {
var faceGradient = this.ctx.createRadialGradient(this.center.x, this.center.y, 0, this.center.x, this.center.y, this.radius);
faceGradient.addColorStop(0, "rgba(255, 231, 180, 0)");
faceGradient.addColorStop(1, "rgba(182, 157, 100, 0.3)");
this.ctx.fillStyle=faceGradient;

this.ctx.beginPath();
this.ctx.arc(this.center.x, this.center.y, this.radius, 0, 2 * Math.PI);

this.ctx.fillStyle='#fff';
this.ctx.fill();
this.ctx.fillStyle=faceGradient;
this.ctx.fill();

var edgeGradient = this.ctx.createLinearGradient(0, this.center.y - this.radius, 0, this.center.y + this.radius);
edgeGradient.addColorStop(0, "#999");
edgeGradient.addColorStop(0.5, "#fff");
edgeGradient.addColorStop(1, "#999");
this.ctx.fillStyle=edgeGradient;

this.ctx.beginPath();
this.ctx.arc(this.center.x, this.center.y, this.radius, 0, 2 * Math.PI);

this.ctx.closePath();
this.ctx.arc(this.center.x, this.center.y, this.radius + (this.radius * 0.075), 0, 2 * Math.PI, true);

this.ctx.shadowColor = 'rgba(0,0,0,0.7)';
this.ctx.shadowBlur = this.radius * 0.3;
this.ctx.shadowOffsetY = 1;
this.ctx.fill();
this.ctx.shadowBlur = 0;
this.ctx.shadowOffsetY = 0;
};

Clock.prototype.drawPin = function() {
this.ctx.fillStyle='#999';
this.ctx.beginPath();
this.ctx.arc(this.center.x, this.center.y, 4, 0, 2 * Math.PI);
this.ctx.fill();
};

Clock.prototype.drawMinuteMarkers = function() {
var i = 1;
while (i <= 60) {
var angle = (Math.PI * 2) * (-i / 60);

var startX = (Math.sin(angle) * (this.radius - (this.radius * this.markerOptions.edgeDistanceRatio))) + this.center.x;
var startY = (Math.cos(angle) * (this.radius - (this.radius * this.markerOptions.edgeDistanceRatio))) + this.center.y;

if (i % this.markerOptions.keyMarkers) {
var endX = (Math.sin(angle) * (this.radius - (this.radius * this.markerOptions.lengthRatio) - (this.radius * this.markerOptions.edgeDistanceRatio))) + this.center.x;
var endY = (Math.cos(angle) * (this.radius - (this.radius * this.markerOptions.lengthRatio) - (this.radius * this.markerOptions.edgeDistanceRatio))) + this.center.y;
this.ctx.lineWidth = this.markerOptions.thicknessRatio * this.radius;
} else {
var endX = (Math.sin(angle) * (this.radius - (this.markerOptions.keyMarkerLengthRatio * this.radius) - (this.radius * this.markerOptions.edgeDistanceRatio))) + this.center.x;
var endY = (Math.cos(angle) * (this.radius - (this.markerOptions.keyMarkerLengthRatio * this.radius) - (this.radius * this.markerOptions.edgeDistanceRatio))) + this.center.y;
this.ctx.lineWidth = this.markerOptions.keyMarkerThicknessRatio * this.radius;
}

this.ctx.strokeStyle = this.markerOptions.color;

this.ctx.beginPath();
this.ctx.moveTo(startX, startY);
this.ctx.lineTo(endX, endY);
this.ctx.stroke();

i++;
}
};

//שעון חורף(2)
Clock.prototype.drawSecondHand = function() {
    var milliseconds = ((Date.now() + (3 * 60 * 60 * 1000)) / 1000) % 60;
    var handAngle = Math.max(-Math.PI * 2, (Math.PI * 2) * (-milliseconds / 58.5));

    this.drawHand(handAngle, this.secondHandOptions);
};

Clock.prototype.drawMinuteHand = function() {
    var now = Date.now() + (3 * 60 * 60 * 1000);
    var totalSeconds = (now / 1000) % 3600;
    var currentSecond = totalSeconds % 60;
    var baseMinutes = Math.floor(totalSeconds / 60);
    
    var minuteProgress = 0;
    if (currentSecond <= 0.5) {
        minuteProgress = currentSecond / 0.5;
    } else {
        minuteProgress = 1;
    }
    
    var minutes = baseMinutes + minuteProgress;
    var handAngle = (Math.PI * 2) * (-minutes / 60);

    this.drawHand(handAngle, this.minuteHandOptions);
};

Clock.prototype.drawHourHand = function() {
    var hours = ((Date.now() + (2 * 60 * 60 * 1000)) / 3600000) % 12;
    var handAngle = (Math.PI * 2) * (-hours / 12);

    this.drawHand(handAngle, this.hourHandOptions);
};

Clock.prototype.drawHand = function(angle, handOptions) {
var startX = (Math.sin(angle) * (this.radius * handOptions.backwardRadiusRatio)) + this.center.x;
var startY = (Math.cos(angle) * (this.radius * handOptions.backwardRadiusRatio)) + this.center.y;

var endX = (Math.sin(angle - Math.PI) * (this.radius * handOptions.forwardRadiusRatio)) + this.center.x;
var endY = (Math.cos(angle - Math.PI) * (this.radius * handOptions.forwardRadiusRatio)) + this.center.y;

this.ctx.shadowColor = 'rgba(0,0,0,0.8)';
this.ctx.shadowBlur = this.radius * 0.075;
this.ctx.shadowOffsetY = 1;

this.ctx.strokeStyle = handOptions.color;
this.ctx.lineWidth = handOptions.thicknessRatio * this.radius;

this.ctx.beginPath();
this.ctx.moveTo(startX, startY);
this.ctx.lineTo(endX, endY);
this.ctx.stroke();

if (handOptions.tipRadiusRatio) {
this.ctx.fillStyle = handOptions.color;
this.ctx.beginPath();
this.ctx.arc(endX, endY, handOptions.tipRadiusRatio * this.radius, 0, 2 * Math.PI);
this.ctx.fill();
}

this.ctx.shadowBlur = 0;
this.ctx.shadowOffsetY = 0;

if (handOptions.tipRadiusRatio) {
this.ctx.beginPath();
this.ctx.moveTo(startX, startY);
this.ctx.lineTo(endX, endY);
this.ctx.stroke();
}
};

sizeCanvas();

var clock = new Clock(canvas, clockRadius());

function clockRadius() {
return Math.min(window.innerWidth, window.innerHeight) * 0.70;
}

function sizeCanvas() {
canvas.width = window.innerWidth * 2;
canvas.height = window.innerHeight * 2;
}

function render() {
clock.update();
requestAnimationFrame(render);
}

render();

var lastWidth = window.innerWidth;

window.addEventListener('resize', function(e){
if (window.innerWidth != lastWidth) {
clock.radius = clockRadius();
lastWidth = window.innerWidth;
sizeCanvas();
}
});
})();
</script>

<script>
    dayjs.extend(dayjs_plugin_duration);
    dayjs.extend(dayjs_plugin_customParseFormat);

//Latitude Longitude
    const LAT = -23;
    const LNG = -20;
    const TIMEZONE = 'Asia/Jerusalem';
    const TWO_HOURS_IN_MS = 2 * 60 * 60 * 1000;

    let netzTime = null;
    let sunsetTime = null;
    let alotHashaharTime = null;
    let mode = 'netz';
    let countdownInterval = null;

    function getElement(id) {
        const element = document.getElementById(id);
        if (!element) {
            console.error(`Erreur fatale: Élément avec ID "${id}" non trouvé.`);
            return { textContent: 'שגיאה', innerHTML: 'שגיאה', style: {} };
        }
        return element;
    }

    function updateClock() {
        const now = dayjs();
        const daysFr = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'];
        const monthsFr = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];

        const dayNameFr = daysFr[now.day()];
        const monthNameFr = monthsFr[now.month()];

        const hh = now.format('HH');
        const mm = now.format('mm');
        const ss = now.format('ss');
        const dd = now.format('DD');
        const yyyy = now.format('YYYY');

        getElement('current-time').innerHTML = `${hh}:${mm}<span class="regular-seconds">:${ss}</span>`;
        getElement('current-date').textContent = `${dayNameFr}, ${dd} ${monthNameFr} ${yyyy}`;
    }

    function calculateAlotHashahar(netz) {
        return netz.subtract(72, 'minutes');
    }

    function startCountdown(targetTime, targetId) {
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }
        if (!targetTime) return;

        const $countdownElement = getElement(`countdown-${targetId}`);
        const $countdownContainer = getElement(`${targetId}-countdown-container`);

        const otherTargetId = targetId === 'netz' ? 'sunset' : 'netz';
        const $otherContainer = getElement(`${otherTargetId}-countdown-container`);
        $otherContainer.style.display = 'none';

        const tick = () => {
            const now = dayjs();
            const diffMs = targetTime.diff(now);

            if (diffMs <= 0) {
                $countdownElement.textContent = 'עבר הזמן';
                $countdownElement.style.color = 'red';
                $countdownContainer.style.display = 'block';
                clearInterval(countdownInterval);

                setTimeout(() => {
                    mode = (targetId === 'netz') ? 'sunset' : 'netz';
                    fetchZmanim(mode === 'netz');
                }, 5000);
                return;
            }

            // Toujours afficher le compte à rebours
            // Afficher uniquement dans les 2 heures avant
if (diffMs > TWO_HOURS_IN_MS) {
    $countdownContainer.style.display = 'none';
    return;
}

$countdownContainer.style.display = 'block';


            const duration = dayjs.duration(diffMs);

            const h = duration.hours().toString();
            const m = duration.minutes().toString().padStart(2, '0');
            const s = duration.seconds().toString().padStart(2, '0');
            const timeStr = `${h}:${m}:${s}`;

            let color = targetId === 'netz' ? 'blue' : 'orange';
            if (diffMs <= 2 * 60 * 1000) {
                color = 'red';
            } else if (diffMs <= 5 * 60 * 1000) {
                color = 'orange';
            }

            $countdownElement.textContent = timeStr;
            $countdownElement.style.color = color;
        };

        tick();
        countdownInterval = setInterval(tick, 1000);
    }

    async function fetchZmanim(forceTomorrow = false) {
        let isTomorrow = forceTomorrow;
        const now = dayjs();
       
        const todayDate = now.format('YYYY-MM-DD');
        let todayData = null;
        let actualSunsetToday = null;

        try {
            const todayUrl = `https://api.sunrisesunset.io/json?lat=${LAT}&lng=${LNG}&date=${todayDate}&timezone=${TIMEZONE}`;
            const response = await fetch(todayUrl);
            if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
            todayData = await response.json();
           
            if (todayData && todayData.results) {
                actualSunsetToday = dayjs(`${todayDate} ${todayData.results.sunset}`, 'YYYY-MM-DD h:mm:ss A');
               
                if (now.isAfter(actualSunsetToday)) {
                    isTomorrow = true;
                }
            }
        } catch (error) {
             console.warn("Échec de la vérification initiale des Zmanim d'aujourd'hui.", error);
             if (now.hour() >= 18) {
                 isTomorrow = true;
             }
        }
       
        const targetDate = dayjs().add(isTomorrow ? 1 : 0, 'day').format('YYYY-MM-DD');
        const finalUrl = `https://api.sunrisesunset.io/json?lat=${LAT}&lng=${LNG}&date=${targetDate}&timezone=${TIMEZONE}`;

        try {
            const response = await fetch(finalUrl);
            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }
            const data = await response.json();

            if (!data || !data.results || !data.results.sunrise || !data.results.sunset) {
                throw new Error('Données Zmanim incomplètes ou manquantes dans la réponse API.');
            }

            const { sunrise, sunset } = data.results;

            netzTime = dayjs(`${targetDate} ${sunrise}`, 'YYYY-MM-DD h:mm:ss A');
            sunsetTime = dayjs(`${targetDate} ${sunset}`, 'YYYY-MM-DD h:mm:ss A');
            alotHashaharTime = calculateAlotHashahar(netzTime);
           
            const suffix = isTomorrow ? ' <span class="zman-time-tomorrow">(מחר)</span>' : '';

            getElement('alot-hashahar-time').innerHTML = `<span class="zman-time">${alotHashaharTime.format('H:mm')}</span>${suffix}`;
            getElement('sunrise-time').innerHTML = `<span class="zman-time">${netzTime.format('H:mm:ss')}</span>${suffix}`;

            if (actualSunsetToday) {
                 getElement('sunset-time').innerHTML = `<span class="zman-time">${actualSunsetToday.format('H:mm')}</span>`;
            } else {
                 getElement('sunset-time').innerHTML = `<span class="zman-time">${sunsetTime.format('H:mm')}</span>`;
            }

            const diffSunset = actualSunsetToday ? actualSunsetToday.diff(now) : -1;
           
            if (diffSunset > 0) {
                mode = 'sunset';
                getElement('sunset-countdown-title').textContent = 'ספירה לשקיעה';
                startCountdown(actualSunsetToday, 'sunset');
            } else {
                mode = 'netz';
                getElement('netz-countdown-title').textContent = 'ספירה לנץ';
                startCountdown(netzTime, 'netz');
            }

        } catch (error) {
            console.error(`Échec de la récupération des Zmanim: ${error.message}`);
            getElement('countdown-netz').textContent = 'שגיאת API';
            getElement('countdown-sunset').textContent = 'שגיאת API';
            getElement('alot-hashahar-time').textContent = 'שגיאה';
            getElement('sunrise-time').textContent = 'שגיאה';
            getElement('sunset-time').textContent = 'שגיאה';
        }
    }

    async function fetchJewishCalendarData() {
        try {
            const response = await fetch('https://www.sefaria.org/api/calendars');
            if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
            const data = await response.json();

            const dafYomi = data.calendar_items.find(item => item.title?.he === 'דף יומי');
            getElement('dailyDaf').textContent = dafYomi?.displayValue?.he || 'לא נמצא דף';

            const parashaItem = data.calendar_items.find(item => item.title?.he === 'פרשת השבוע');
            getElement('parashaName').textContent = parashaItem?.displayValue?.he || 'לא נמצאה פרשה';

        } catch (error) {
            console.error('שגיאה בשליפת מידע Sefaria:', error);
            getElement('dailyDaf').textContent = 'שגיאה';
            getElement('parashaName').textContent = 'שגיאה';
        }
    }

    async function fetchHebrewDate() {
        try {
            const today = dayjs();
            const gy = today.year();
            const gm = today.month() + 1;
            const gd = today.date();

            const response = await fetch(`https://www.hebcal.com/converter?cfg=json&gy=${gy}&gm=${gm}&gd=${gd}&g2h=1`);
            if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
            const data = await response.json();

            if (data && data.hebrew) {
                getElement('dateHeb').textContent = data.hebrew;
            } else {
                getElement('dateHeb').textContent = 'תאריך לא זמין';
            }
        } catch (error) {
            console.error('שגיאה בשליפת התאריך העברי:', error);
            getElement('dateHeb').textContent = 'שגיאה';
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        updateClock();
        setInterval(updateClock, 1000);

        fetchJewishCalendarData();
        fetchHebrewDate();
        fetchZmanim();
    });
</script>
</body>
</html>
